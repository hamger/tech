### 从输入URL到看到页面发生的全过程

1. 首先浏览器主进程接管，开了一个下载线程。
2. 然后进行HTTP请求（DNS查询、IP寻址等等），中间会有三次捂手，等待响应，开始下载响应报文。
3. 将下载完的内容转交给Renderer进程管理。
4. Renderer进程开始解析css rule tree和dom tree，这两个过程是并行的
5. 解析绘制过程中，当浏览器遇到link标签或者script、img等标签，浏览器会去下载这些内容，遇到时候缓存的使用缓存，不适用缓存的重新下载资源。
6. css rule tree和dom tree生成完了之后，开始合成render tree，这个时候浏览器会进行layout，开始计算每一个节点的位置，然后进行绘制。
7. 绘制结束后，关闭TCP连接，过程有四次挥手。

> **TCP是全双工模式**，也就是说，当主机1告诉主机2我没有数据要发送了，但是主机1仍然可以接收来自主机2的数据，什么时候可以不接收来自主机2的数据呢，就是主机2告诉主机1他没有数据要发送了，此时双方都没有数据需要发送了，TCP连接就会断开。

> 数据通过网络从 A 端到 B 端依次经过了：A 端的应用层、传输层、网络层、链路层（每通过一层增加首部），B 端的链路层、网络层、传输层、应用层（每通过一层删除首部）。

#### 三次握手
1. 客户端 -> SYN=1, seq=x -> 服务端
2. 服务端 -> SYN=1, ACK=1, seq=y, ack=x+1 -> 客户端
3. 客户端 -> ACK=1, seq=x+1, ack=y+1 -> 服务端

> seq(sequence number):表示的是发送方的，packet 的数据部分的第一位应该在整个data stream 中所在的位置
> ack(acknowledge number):表示的是期望的接收方的下一次 sequence number 是多少。

#### 四次挥手
1. 客户端 -> FIN=1, seq=u -> 服务端
2. 服务端 -> ACK=1, seq=v, ack=u+1 -> 客户端
3. 服务端 -> FIN=1, ACK=1, seq=w, ack=u+1 -> 客户端
4. 客户端 -> ACK=1, seq=u+1, ack=w+1 -> 服务端

[关于三次握手的四次挥手的详细文章](https://blog.csdn.net/qzcsu/article/details/72861891)

### http 与 https 的区别

| 区别     | http                                                            | https                                                                                                            |
| -------- | --------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- |
| 协议     | 运行在 TCP 之上，明文传输，客户端与服务器端都无法验证对方的身份 | 身披 SSL( Secure Socket Layer )外壳的 HTTP，运行于 SSL 上，SSL 运行于 TCP 之上， 是添加了加密和认证机制的 HTTP。 |
| 端口     | 80                                                              | 443                                                                                                              |
| 资源消耗 | 较少                                                            | 由于加解密处理，会消耗更多的 CPU 和内存资源                                                                      |
| 开销     | 无需证书                                                        | 需要证书，而证书一般需要向认证机构购买                                                                           |
| 加密机制 | 无                                                              | 共享密钥加密和公开密钥加密并用的混合加密机制                                                                     |
| 安全性   | 弱                                                              | 由于加密机制，安全性强                                                                                           |

### http/2 优势

- 多路复用 (Multiplexing)：允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息
- 二进制分帧：在应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个帧，并采用二进制编码
- 服务端推送（Server Push）：服务端推送是一种在客户端请求之前发送数据的机制
- 报文头压缩：对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量

### HTTP 缓存

HTTP 缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类：强制缓存，协商缓存（也叫对比缓存）。
对于强缓存，浏览器在第一次请求的时候，会直接下载资源，然后缓存在本地，第二次请求的时候，直接使用缓存，不发起 http 请求。
对于协商缓存，第一次请求保存资源标识与时间，第二次请求向服务器发送资源标识和最后缓存时间，服务端进行校验，如果失效则返回 200 和新的资源，如果资源没有变更则返回 304 。

强缓存方案：

- Exprires：属于 HTTP 1.0 的内容，表示服务端返回的到期时间，缺陷是在服务端和客户端时间不同步的情况下会导致缓存命中误差。

- Cache-control：常见的取值有 private、public、no-cache、max-age，no-store，默认为 private。

```
private:         客户端可以缓存
public:          客户端和代理服务器都可以缓存
max-age=xxx:     缓存的内容将在 xxx 秒后失效
no-cache:        需要使用对比缓存来验证缓存数据
no-store:        所有内容都不会缓存，强制缓存和对比缓存都不会触发
```

协商缓存方案：

- Last-modified / If-Modified-Since：都是表示时间的字符串，响应头中带 Last-modified 表明资源的修改时间，第二次请求的时候客户端带上请求头 If-Modified-Since ，表示资源上次的修改时间，服务端进行对比。

- ETag / If-None-Match：都是一个标识字符串，优先级高于 Last-Modified / If-Modified-Since，第一次请求的时候，服务端会返回 ETag 标识给客户端，第二次请求的时候客户端请求头带上 If-None-Match 标识，服务端进行对比。

[HTTP 缓存机制详解](https://juejin.im/entry/599afbe5f265da247c4ee6e3)

### GET 与 POST 的区别

GET 和 POST 本质上就是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。

- GET 参数通过 URL 传递，POST 放在 Request body 中。
- GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。
- GET 请求只能进行 url 编码，而 POST 支持多种编码方式。
- GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有。
- 对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。
- GET 产生一个 TCP 数据包（ header 和 data ）；POST 产生两个 TCP 数据包（先发送 header，服务器响应 100 ，再发送 data）。

[HTTP 中 GET 与 POST 的区别](https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&mid=100000054&idx=1&sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd)

### WebSocket 协议

WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。

- 更少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。
- 更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。
- 保持连接状态。Websocket 是一种有状态的协议，之后通信时可以省略部分状态信息。
- 更好的二进制支持。Websocket 定义了二进制帧，相对 HTTP，可以更轻松地处理二进制内容。
- 可以支持扩展。Websocket 定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。
