### 从输入 URL 到看到页面发生的全过程

1. 首先浏览器主进程接管，开了一个下载线程。
2. 然后进行 HTTP 请求（DNS 查询、IP 寻址等等），中间会有三次捂手，等待响应，开始下载响应报文。
3. 将下载完的内容转交给 Renderer 进程管理。
4. Renderer 进程开始解析 css rule tree 和 dom tree，这两个过程是并行的
5. 解析绘制过程中，当浏览器遇到 link 标签或者 script、img 等标签，浏览器会去下载这些内容，优先使用可用的缓存。
6. css rule tree 和 dom tree 生成完了之后，开始合成 render tree，这个时候浏览器会进行 layout，开始计算每一个节点的位置，然后进行绘制。
7. 绘制结束后，关闭 TCP 连接，过程有四次挥手。

> **TCP 是全双工模式**，也就是说，当主机 1 告诉主机 2 我没有数据要发送了，但是主机 1 仍然可以接收来自主机 2 的数据，当主机 2 告诉主机 1 我也没有数据要发送了，此时双方都没有数据需要发送了，TCP 连接就会断开。

> 数据通过网络从 A 端到 B 端依次经过了：A 端的应用层、传输层、网络层、链路层（每通过一层增加首部），B 端的链路层、网络层、传输层、应用层（每通过一层删除首部）。

### CSS 和 JS 的位置为何会影响页面效率

css 在加载过程中不会影响到 DOM 树的生成，但是会影响到 Render 树的生成，进而影响到 layout，所以一般来说，style 的 link 标签需要尽量放在 head 里面，因为在解析 DOM 树的时候是自上而下的，而 css 样式又是通过异步加载的，这样的话，解析 DOM 树下的 body 节点和加载 css 样式能尽可能的并行，加快 Render 树的生成的速度。

js 脚本应该放在底部，原因在于 JS 引擎线程（单线程）与 GUI 渲染线程是互斥的关系，如果 js 放在首部，当下载执行 js 的时候，会影响 GUI 渲染线程绘制页面，js 的作用主要是处理交互，而交互必须得先让页面呈现才能进行，所以为了保证用户体验，尽量让页面先绘制出来。

### 三次握手

1. 客户端 -> SYN=1, seq=x -> 服务端
2. 服务端 -> SYN=1, ACK=1, seq=y, ack=x+1 -> 客户端
3. 客户端 -> ACK=1, seq=x+1, ack=y+1 -> 服务端

> seq(sequence number):表示的是发送方的，packet 的数据部分的第一位应该在整个 data stream 中所在的位置
> ack(acknowledge number):表示的是期望的接收方的下一次 sequence number 是多少。

### 四次挥手

1. 客户端 -> FIN=1, seq=u -> 服务端
2. 服务端 -> ACK=1, seq=v, ack=u+1 -> 客户端
3. 服务端 -> FIN=1, ACK=1, seq=w, ack=u+1 -> 客户端
4. 客户端 -> ACK=1, seq=u+1, ack=w+1 -> 服务端

[关于三次握手的四次挥手的详细文章](https://blog.csdn.net/qzcsu/article/details/72861891)

### http 协议

HTTP 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，HTTP 是一个基于 TCP/IP 通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。

#### 特点

1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。

2、灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。

3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

4.无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

5、支持 B/S 及 C/S 模式。

#### http 状态码

| 状态码   | 描述                                                                           |
| -------- | ------------------------------------------------------------------------------ |
| 100      | 客户端应继续其请求                                                             |
| 301      | 永久重定向                                                                     |
| 302、307 | 临时重定向                                                                     |
| 304      | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源             |
| 305      | 使用代理。所请求的资源必须通过代理访问                                         |
| 400      | 客户端请求的语法错误，服务器无法理解                                           |
| 401      | 请求要求用户的身份认证                                                         |
| 403      | 服务器理解请求客户端的请求，但是拒绝执行此请求                                 |
| 404      | 服务器无法根据客户端的请求找到资源（网页）                                     |
| 405      | 客户端请求中的方法被禁止                                                       |
| 407      | 请求要求代理的身份认证，与 401 类似，但请求者应当使用代理进行授权              |
| 408      | 服务器等待客户端发送的请求时间过长，超时                                       |
| 500      | 服务器内部错误，无法完成请求                                                   |
| 501      | 服务器不支持请求的功能，无法完成请求                                           |
| 502      | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
| 503      | 由于超载或系统维护，服务器暂时的无法处理客户端的请求                           |
| 504      | 充当网关或代理的服务器，未及时从远端服务器获取请求                             |
| 505      | 服务器不支持请求的 HTTP 协议的版本，无法完成处理                               |

#### http 与 https 的区别

| 区别     | http                                                            | https                                                                                                            |
| -------- | --------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- |
| 协议     | 运行在 TCP 之上，明文传输，客户端与服务器端都无法验证对方的身份 | 身披 SSL( Secure Socket Layer )外壳的 HTTP，运行于 SSL 上，SSL 运行于 TCP 之上， 是添加了加密和认证机制的 HTTP。 |
| 端口     | 80                                                              | 443                                                                                                              |
| 资源消耗 | 较少                                                            | 由于加解密处理，会消耗更多的 CPU 和内存资源                                                                      |
| 开销     | 无需证书                                                        | 需要证书，而证书一般需要向认证机构购买                                                                           |
| 加密机制 | 无                                                              | 共享密钥加密和公开密钥加密并用的混合加密机制                                                                     |
| 安全性   | 弱                                                              | 由于加密机制，安全性强                                                                                           |

#### http/2 优势

- 多路复用 (Multiplexing)：允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息
- 二进制分帧：在应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个帧，并采用二进制编码
- 服务端推送（Server Push）：服务端推送是一种在客户端请求之前发送数据的机制
- 报文头压缩：对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量

### HTTP 缓存

HTTP 缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类：强缓存（也称本地缓存），协商缓存（也称弱缓存）。
对于强缓存，浏览器在第一次请求的时候，会直接下载资源，然后缓存在本地，第二次请求的时候，直接使用缓存，不发起 http 请求。
对于协商缓存，第一次请求保存资源标识与时间，第二次请求向服务器发送资源标识和最后缓存时间，服务端进行校验，如果失效则返回 200 和新的资源，如果资源没有变更则返回 304 。

强缓存方案：

- Exprires：属于 HTTP 1.0 的内容，表示服务端返回的到期时间，缺陷是在服务端和客户端时间不同步的情况下会导致缓存命中误差。

- Cache-control：常见的取值有 private、public、no-cache、max-age，no-store，默认为 private。

```
private:         客户端可以缓存
public:          客户端和代理服务器都可以缓存
max-age=xxx:     缓存的内容将在 xxx 秒后失效
no-cache:        需要使用对比缓存来验证缓存数据
no-store:        所有内容都不会缓存，强制缓存和对比缓存都不会触发
```

> 强缓存中，普通刷新会忽略它，但不会清除它，需要强制刷新。浏览器强制刷新，请求会带上`Cache-Control:no-cache`和`Pragma:no-cache`

协商缓存方案：

- Last-modified / If-Modified-Since：都是表示时间的字符串，响应头中带 Last-modified 表明资源的修改时间，第二次请求的时候客户端带上请求头 If-Modified-Since ，表示资源上次的修改时间，服务端进行对比。若修改时间一致返回 304 ，否则返回 200 。

- ETag / If-None-Match：都是一个标识字符串，优先级高于 Last-Modified / If-Modified-Since，第一次请求的时候，服务端会返回 ETag 标识给客户端，第二次请求的时候客户端请求头带上 If-None-Match 标识，服务端进行对比。若标识一致返回 304 ，否则返回 200 。

> 普通刷新会启用弱缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存，这也是为什么有时候我们更新一张图片、一个 js 文件，页面内容依然是旧的，但是直接浏览器访问那个图片或文件，看到的内容却是新的。

> Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。

[HTTP 缓存机制详解](https://juejin.im/entry/599afbe5f265da247c4ee6e3)

### GET 与 POST 的区别

GET 和 POST 本质上就是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。

- GET 参数通过 URL 传递，POST 放在 Request body 中。
- GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。
- GET 请求只能进行 url 编码，而 POST 支持多种编码方式。
- GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有。
- 对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。
- GET 产生一个 TCP 数据包（ header 和 data ）；POST 产生两个 TCP 数据包（先发送 header，服务器响应 100 ，再发送 data）。

[HTTP 中 GET 与 POST 的区别](https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&mid=100000054&idx=1&sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd)

### WebSocket 协议

WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。

- 更少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。
- 更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。
- 保持连接状态。Websocket 是一种有状态的协议，之后通信时可以省略部分状态信息。
- 更好的二进制支持。Websocket 定义了二进制帧，相对 HTTP，可以更轻松地处理二进制内容。
- 可以支持扩展。Websocket 定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。
